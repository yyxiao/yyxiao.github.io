---
bg: "tools.jpg"
layout: post
title:  多线程概括
crawlertitle: "Java多线程概况"
summary: "对多线程认知"
date: 2015-05-16 13:38:00
categories: posts
tags: ['Java']
author: Xander
---

在Java程序中，JVM负责线程的调度。线程调度是按照特定的机制为多个线程分配CPU的使用权。

### Java与多线程

在Java中，多线程的实现由两种方式：
 * 扩展java.lang.Thread类
 * 实现java.lang.Runnable接口
 
```text
在使用Runnable接口时需要建立一个Thread实例。因此，无论通过Thread类还是Runnable接口建立线程，
都必须建立Thread类或它的子类的实例。
```

### 多线程的安全

解决办法：对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不执行。

常见场景：操作系统、WEB服务、FTP下载等等

```text
每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。每个线程都可以或不可以标记为一个
守护程序。当某个线程中运行的代码创建一个新的Thread对象时，该新线程的初始优先级被设定为创建线程
的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护程序。
```

#### Thread.run()与Thread.start()的区别

Thread.start()方法启动线程，使之进入就绪状态，当cpu分配时间进行该线程时，由JVM调度执行run()方法。


### 死锁

死锁就是两个或两个以上的线程被无限的阻塞，线程之间相互等待所需资源。这种情况可能发生在当两个线程
尝试获取其它资源的锁，而每个线程又陷入无限等待其它资源锁的释放，除非一个用户进程被终止。就JavaAPI
而言，线程死锁可能发生在一下情况：

* 当两个线程相互调用Thread.join()
* 当两个线程使用嵌套的同步块，一个线程占用了另外一个线程必须的锁，互相等待时被阻塞就有可能出现死锁

### 线程的状态：

1. 新建状态(New)：新创建了一个线程对象。
2. 就绪状态(Runnable)：线程对象创建后，调用了start()。该线程处于线程池中，变得可运行，等待获取CPU
的使用权。
3. 运行状态(Running)：就绪状态的线程获取了CPU，执行程序代码。
4. 阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，
才有机会转到运行状态。
5. 死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

#### 阻塞分类：

 * 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。
 * 同步阻塞：运行的线程在获取对象的同步锁时，若该公布锁被别的线程占用，则JVM会把该线程放入锁池中。
 * 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。
 
* * *

## 2017年04月01日16:26:24修改补充

### 内存模型

Java的并发采用的是共享内存模式，线程间通信是隐式的，同步是显式的。

* 并发编程模型的分类

并发编程中，需要处理两个问题：线程之间如何通信、线程之间如何同步。



